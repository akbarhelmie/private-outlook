<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>LLM Knowledge Graph — Advanced Dashboard (single file)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
    <style>
        body { margin:0; overflow:hidden; font-family: 'Nunito', sans-serif; background:#0c101a; color:#f0f0f0; }
        canvas{ display:block; }
        /* Left info / controls panel (keeps original #info position & look) */
        #info {
            position: absolute; top: 12px; left: 12px;
            width: 360px; max-height: 92vh; overflow-y:auto;
            background: rgba(12,16,26,0.9); backdrop-filter: blur(8px);
            border: 1px solid rgba(255,255,255,0.06);
            padding: 12px; border-radius: 10px; z-index: 110;
            font-size: 14px;
        }
        #info h1 { margin:0 0 8px 0; font-weight:800; font-size:18px; color:#E6F1FF; }
        .module { margin:8px 0; padding:8px; border-radius:8px; background: rgba(255,255,255,0.02); border:1px solid rgba(255,255,255,0.03); }
        .module h3 { margin:0 0 6px 0; font-size:15px; color:#BEE3F8; }
        .module p { margin:0 0 6px 0; color:#cfe6ff; opacity:0.9; font-size:13px; }
        .btn { background:transparent; color:#dff; border:1px solid rgba(255,255,255,0.06); padding:6px 8px; border-radius:6px; cursor:pointer; margin-right:6px; font-size:13px; }
        .small { font-size:12px; color:#94a3b8; }
        #node-inspector-display { margin-top:10px; border-top:1px solid rgba(255,255,255,0.03); padding-top:10px; display:none; }
        #node-inspector-display h2 { color:#90cdf4; margin:0 0 6px 0; font-size:15px; }
        #search-box { width:100%; padding:8px 10px; border-radius:8px; background:rgba(255,255,255,0.03); border:1px solid rgba(255,255,255,0.04); color:#fff; margin-bottom:8px; }
        #search-suggestions { background:rgba(10,14,22,0.95); border-radius:6px; margin-top:6px; max-height:160px; overflow:auto; display:none; border:1px solid rgba(255,255,255,0.03); }
        .suggestion-item { padding:8px 10px; cursor:pointer; }
        .suggestion-item:hover { background:rgba(255,255,255,0.02); }
        .node-label { background:transparent; color:#f0f8ff; text-shadow:0 0 5px rgba(0,0,0,1); pointer-events: all; cursor:pointer; font-size:11px; font-weight:700; }
        .edge-relation-label { background:transparent; color:#a0aec0; text-shadow:0 0 5px rgba(0,0,0,1); pointer-events: all; cursor:pointer; font-size:9px; font-style:italic; }
        .divider { height:1px; background:rgba(255,255,255,0.02); margin:8px 0; }
        #wallet-area input { width:100%; padding:8px 10px; border-radius:6px; background:rgba(255,255,255,0.02); border:1px solid rgba(255,255,255,0.03); color:#fff; }
        #warning { color:#ffb4b4; font-size:12px; margin-top:8px; }
        /* small hint box bottom right */
        #hint { position: absolute; right:12px; bottom:12px; background: rgba(255,255,255,0.03); padding:8px 10px; border-radius:8px; border:1px solid rgba(255,255,255,0.03); font-size:12px; color:#dbeafe; }
    </style>
</head>
<body>
    <div id="info">
        <h1>Evolved Knowledge Graph — Modules</h1>

        <input id="search-box" placeholder="Search nodes (type 2+ chars)..." />
        <div id="search-suggestions"></div>

        <!-- Modules list (6 modules) -->
        <div class="module" id="m1">
            <h3>1. Real-Time Intelligence Dashboard</h3>
            <p class="small">Live crypto & stock feeds, news sentiment, and geopolitical risk overlays. Click <button class="btn" data-node="RealTime_Dashboard">Focus</button> to jump to the node.</p>
        </div>

        <div class="module" id="m2">
            <h3>2. AI Command Center</h3>
            <p class="small">A local AI agent interface (client-side placeholders). Upload files (local) and run mission-mode simulations. Click <button class="btn" data-node="AI_Command_Center">Focus</button>.</p>
            <input type="file" id="ai-files" multiple style="margin-top:6px;">
            <div id="uploaded-list" class="small"></div>
        </div>

        <div class="module" id="m4">
            <h3>3. Global Market Manipulation Radar</h3>
            <p class="small">Order-flow & volume anomaly detection, early alerts to Telegram/Signal (placeholder). Click <button class="btn" data-node="Manipulation_Radar">Focus</button>.</p>
        </div>

        <div class="module" id="m5">
            <h3>4. Human Network Monitor</h3>
            <p class="small">Graph-driven influence mapping and outreach suggestions. Click <button class="btn" data-node="Network_Monitor">Focus</button>.</p>
        </div>

        <div class="module" id="m6">
            <h3>5. Vision & Reality Sync</h3>
            <p class="small">3D mind-maps, timelines and KPIs linking ideas to execution. Click <button class="btn" data-node="Vision_Sync">Focus</button>.</p>
        </div>

        <div class="module" id="m7">
            <h3>6. Autonomous Action Layer</h3>
            <p class="small">IF-THIS-THEN-THAT rules to trigger actions. Monitoring & simulated action buttons below. Click <button class="btn" data-node="Autonomous_Layer">Focus</button>.</p>

            <div id="wallet-area" style="margin-top:8px;">
                <label class="small">Wallet / Exchange info (client-only):</label>
                <input id="wallet-input" placeholder="Paste wallet address or exchange account id (for display only)"/>
                <div style="margin-top:6px;">
                    <button id="btn-monitor" class="btn">Set Monitor Address</button>
                    <button id="btn-sim-trade" class="btn">Execute Simulated Trade</button>
                </div>
                <div id="wallet-status" class="small" style="margin-top:6px;">No wallet being monitored.</div>
                <div id="warning">⚠️ For security, this page does NOT execute real trades by itself. Integrating real trading requires a secure backend and safe storage of API keys. See notes below.</div>
            </div>
        </div>

        <div class="divider"></div>

        <div id="node-inspector-display">
            <h2 id="node-inspector-title">Node Details</h2>
            <p><strong>ID:</strong> <span id="node-id-text"></span></p>
            <p><strong>Type:</strong> <span id="node-type-text"></span></p>
            <p><strong>Category:</strong> <span id="node-category-text"></span></p>
            <div id="node-connections-details" style="display:none;">
                <p><strong>Direct Connections:</strong></p>
                <ul id="node-connections-list"></ul>
            </div>
        </div>

        <div class="small" style="margin-top:10px; opacity:0.9;">
            Next steps: If you want actual exchange/monitoring integration, I can generate a secure minimal backend (Node.js + express) that stores your API keys safely, performs signed orders, and exposes only a safe endpoint for this UI. Running trading from client-side is insecure and not recommended.
        </div>
    </div>

    <div id="hint">Click node labels to inspect • Click blank area to clear</div>

    <!-- Three.js and CSS2DRenderer (same versions as original) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/renderers/CSS2DRenderer.js"></script>

    <script>
    // === Core: adapted from your original file to keep behavior intact ===

    // --- Data Definitions (new graph content: 6 modules + subnodes) ---
    const graphDataFull = {
        "nodes": [
            // Person node (retain Akbar)
            {"id":"Akbar","type":"Person","displayText":"Akbar"},

            // Module nodes (top-level)
            {"id":"RealTime_Dashboard","type":"Module","displayText":"Real-Time Intelligence Dashboard"},
            {"id":"AI_Command_Center","type":"Module","displayText":"AI Command Center"},
            {"id":"Manipulation_Radar","type":"Module","displayText":"Global Market Manipulation Radar"},
            {"id":"Network_Monitor","type":"Module","displayText":"Human Network Monitor"},
            {"id":"Vision_Sync","type":"Module","displayText":"Vision & Reality Sync"},
            {"id":"Autonomous_Layer","type":"Module","displayText":"Autonomous Action Layer"},

            // Subnodes for Real-Time Dashboard
            {"id":"RT_CryptoFeed","type":"Submodule","displayText":"Crypto & Orderbooks"},
            {"id":"RT_StockFeed","type":"Submodule","displayText":"Stock & Indices"},
            {"id":"RT_NewsSentiment","type":"Submodule","displayText":"News Sentiment Engine"},
            {"id":"RT_GeoRisk","type":"Submodule","displayText":"Geopolitical Risk Map"},

            // Subnodes for AI Command Center
            {"id":"AI_LocalAgent","type":"Submodule","displayText":"Local NL Agent"},
            {"id":"AI_MissionMode","type":"Submodule","displayText":"Mission Mode Planner"},
            {"id":"AI_FileReader","type":"Submodule","displayText":"File Reader (client files)"},
            {"id":"AI_DocGen","type":"Submodule","displayText":"Doc / Draft Composer"},

            // Subnodes for Manipulation Radar
            {"id":"Radar_OrderFlow","type":"Submodule","displayText":"Order Flow Monitor"},
            {"id":"Radar_Anomalies","type":"Submodule","displayText":"Anomaly Detector"},
            {"id":"Radar_Alerts","type":"Submodule","displayText":"Alerts & Integrations"},

            // Subnodes for Network Monitor
            {"id":"Net_Contacts","type":"Submodule","displayText":"Contacts Database"},
            {"id":"Net_Influence","type":"Submodule","displayText":"Influence Scoring"},
            {"id":"Net_Mentions","type":"Submodule","displayText":"Mentions & Alerts"},

            // Subnodes for Vision Sync
            {"id":"Vision_Holoboard","type":"Submodule","displayText":"Holo-Board (3D maps)"},
            {"id":"Vision_Timeline","type":"Submodule","displayText":"Timeline & Milestones"},
            {"id":"Vision_KPIs","type":"Submodule","displayText":"KPIs & Tracking"},

            // Subnodes for Autonomous Layer
            {"id":"Auto_Rules","type":"Submodule","displayText":"IF-THIS-THEN-THAT Rules Engine"},
            {"id":"Auto_Actions","type":"Submodule","displayText":"Actions (Alerts/Exec)"},
            {"id":"Auto_Safety","type":"Submodule","displayText":"Safety & Guardrails"},

            // Wallet / monitoring placeholder node
            {"id":"Wallet_Monitor","type":"Submodule","displayText":"Wallet / Exchange Monitor (client-only)"}
        ],
        "edges": [
            // Connect person to modules (Akbar owns / uses)
            {"source":"Akbar","target":"RealTime_Dashboard","relation":"uses"},
            {"source":"Akbar","target":"AI_Command_Center","relation":"operates"},
            {"source":"Akbar","target":"Manipulation_Radar","relation":"monitors"},
            {"source":"Akbar","target":"Network_Monitor","relation":"leverages"},
            {"source":"Akbar","target":"Vision_Sync","relation":"plans"},
            {"source":"Akbar","target":"Autonomous_Layer","relation":"configures"},

            // Connect modules to their subnodes
            {"source":"RealTime_Dashboard","target":"RT_CryptoFeed","relation":"includes"},
            {"source":"RealTime_Dashboard","target":"RT_StockFeed","relation":"includes"},
            {"source":"RealTime_Dashboard","target":"RT_NewsSentiment","relation":"includes"},
            {"source":"RealTime_Dashboard","target":"RT_GeoRisk","relation":"includes"},

            {"source":"AI_Command_Center","target":"AI_LocalAgent","relation":"hosts"},
            {"source":"AI_Command_Center","target":"AI_MissionMode","relation":"supports"},
            {"source":"AI_Command_Center","target":"AI_FileReader","relation":"reads"},
            {"source":"AI_Command_Center","target":"AI_DocGen","relation":"generates"},

            {"source":"Manipulation_Radar","target":"Radar_OrderFlow","relation":"monitors"},
            {"source":"Manipulation_Radar","target":"Radar_Anomalies","relation":"detects"},
            {"source":"Manipulation_Radar","target":"Radar_Alerts","relation":"alerts"},

            {"source":"Network_Monitor","target":"Net_Contacts","relation":"stores"},
            {"source":"Network_Monitor","target":"Net_Influence","relation":"scores"},
            {"source":"Network_Monitor","target":"Net_Mentions","relation":"watches"},

            {"source":"Vision_Sync","target":"Vision_Holoboard","relation":"visualizes"},
            {"source":"Vision_Sync","target":"Vision_Timeline","relation":"schedules"},
            {"source":"Vision_Sync","target":"Vision_KPIs","relation":"tracks"},

            {"source":"Autonomous_Layer","target":"Auto_Rules","relation":"evaluates"},
            {"source":"Autonomous_Layer","target":"Auto_Actions","relation":"executes"},
            {"source":"Autonomous_Layer","target":"Auto_Safety","relation":"enforces"},
            {"source":"Autonomous_Layer","target":"Wallet_Monitor","relation":"observes"},

            // cross links (some suggested connections)
            {"source":"RT_NewsSentiment","target":"Radar_Anomalies","relation":"feeds"},
            {"source":"Radar_Alerts","target":"AI_Command_Center","relation":"notifies"},
            {"source":"Net_Mentions","target":"RT_NewsSentiment","relation":"context_for"}
        ]
    };

    // Keep the original nodeColorsFull mapping (trimmed for brevity)
    const nodeColorsFull = {
        "Person":0xFF6347,
        "Module":0x4A90E2,
        "Submodule":0x20B2AA,
        "default":0xA9A9A9
    };

    // --- Graph rendering variables (mostly preserved from original) ---
    let scene, camera, renderer, labelRenderer, controls, raycaster, mouse, clock;
    let graphGroup;
    const nodes = new Map();
    const edges = [];
    let searchIndex = [];
    let highlightedElements = null;
    const NORMAL_NODE_OPACITY = 0.9;
    const FAINT_OPACITY = 0.06;
    let autoRotation = true;
    let autoRotationSpeed = 0.0004;

    // small shaders (copied lightly)
    const flowVertexShader = `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }`;
    const flowFragmentShader = `
        uniform vec3 uColor;
        uniform float uTime;
        uniform float uFlowSpeed;
        uniform float uIsHighlighted;
        varying vec2 vUv;
        void main() {
            float flow = sin(vUv.x * 30.0 + uTime * uFlowSpeed) * 0.5 + 0.5;
            flow = pow(flow, 4.0);
            vec3 baseColor = uColor;
            float baseAlpha = 0.35;
            if (uIsHighlighted > 0.5) {
                baseColor = vec3(1.0, 1.0, 0.0);
                baseAlpha = 0.95;
            }
            vec3 finalColor = baseColor + baseColor * flow * 3.0;
            gl_FragColor = vec4(finalColor, baseAlpha);
        }`;

    // Helper functions
    function relationToColor(relationString){
        let hash = 0;
        for (let i = 0; i < relationString.length; i++) {
            hash = relationString.charCodeAt(i) + ((hash << 5) - hash);
        }
        const color = (hash & 0x00FFFFFF).toString(16).toUpperCase();
        return parseInt("00000".substring(0, 6 - color.length) + color, 16);
    }

    function getNodeCategory(node) {
        const type = node.type;
        if (type === 'Person') return 'Person';
        if (type === 'Module') return 'Module';
        if (type === 'Submodule') return 'Submodule';
        return 'Key Concepts';
    }

    function onWindowResize(){
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        labelRenderer.setSize(window.innerWidth, window.innerHeight);
    }

    function init(){
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(75,window.innerWidth/window.innerHeight,0.1,1000);
        camera.position.z = 60;
        clock = new THREE.Clock();
        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();

        renderer = new THREE.WebGLRenderer({antialias:true, alpha:true});
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        labelRenderer = new THREE.CSS2DRenderer();
        labelRenderer.domElement.style.position = 'absolute';
        labelRenderer.domElement.style.top = '0px';
        labelRenderer.domElement.style.pointerEvents = 'none';
        labelRenderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(labelRenderer.domElement);

        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.minDistance = 5;
        controls.maxDistance = 250;
        controls.addEventListener('start', ()=>{});
        controls.addEventListener('end', ()=>{});

        scene.add(new THREE.AmbientLight(0xffffff, 0.8));
        const dir = new THREE.DirectionalLight(0xffffff, 0.7);
        dir.position.set(8,15,10);
        scene.add(dir);

        graphGroup = new THREE.Group();
        scene.add(graphGroup);

        buildSearchIndex();
        const connCounts = computeConnectionCounts();
        createNodes(connCounts);
        createEdges();

        window.addEventListener('resize', onWindowResize);
        document.addEventListener('click', onDocumentClick, false);

        animate();
    }

    function computeConnectionCounts(){
        const map = new Map();
        graphDataFull.nodes.forEach(n=>map.set(n.id,0));
        graphDataFull.edges.forEach(e=>{
            map.set(e.source, (map.get(e.source)||0)+1);
            map.set(e.target, (map.get(e.target)||0)+1);
        });
        return map;
    }

    function createNodes(connectionCounts){
        const nodeCategories = {};
        graphDataFull.nodes.forEach(node=>{
            const cat = getNodeCategory(node);
            if(!nodeCategories[cat]) nodeCategories[cat]=[];
            nodeCategories[cat].push(node);
        });

        const categoryRadii = {'Person':0,'Module':18,'Submodule':36,'Key Concepts':52};
        const goldenAngle = Math.PI * (3 - Math.sqrt(5));

        Object.entries(nodeCategories).forEach(([category, nodesInCategory])=>{
            const radius = categoryRadii[category] !== undefined ? categoryRadii[category] : 60;
            nodesInCategory.forEach((nodeData, i)=>{
                const nodeGroup = new THREE.Group();
                nodeData.randomOffset = Math.random()*1000;

                if (nodeData.id !== 'Akbar') {
                    const y = nodesInCategory.length > 1 ? 1 - (i / (nodesInCategory.length - 1)) * 2 : 0;
                    const radiusAtY = Math.sqrt(Math.max(0,1 - y*y));
                    const theta = goldenAngle * i;
                    nodeGroup.position.set(Math.cos(theta) * radiusAtY * radius, y * radius, Math.sin(theta) * radiusAtY * radius);
                }

                const color = nodeColorsFull[nodeData.type] || nodeColorsFull.default;
                nodeData.originalColor = new THREE.Color(color);

                const size = nodeData.type === 'Person' ? 1.6 : (nodeData.type === 'Module' ? 1.3 : 0.95);

                const sphere = new THREE.Mesh(
                    new THREE.SphereGeometry(size, 28, 16),
                    new THREE.MeshStandardMaterial({
                        color: nodeData.originalColor, transparent: true, opacity: NORMAL_NODE_OPACITY,
                        metalness: 0.1, roughness: 0.7, emissive: 0x000000
                    })
                );
                sphere.userData = { nodeData, isNodeSphere: true };
                nodeGroup.add(sphere);

                const ringsGroup = new THREE.Group();
                const ringCount = Math.min(5, connectionCounts.get(nodeData.id) || 0);
                for (let j=0;j<ringCount;j++){
                    const ringRadius = (size * 1.25) + j * (size * 0.22);
                    const ring = new THREE.Mesh(
                        new THREE.RingGeometry(ringRadius, ringRadius+0.04, 64),
                        new THREE.MeshBasicMaterial({ color: nodeData.originalColor, side: THREE.DoubleSide, transparent: true, opacity: 0.16 })
                    );
                    ring.rotation.x = Math.random() * Math.PI;
                    ring.rotation.y = Math.random() * Math.PI;
                    ringsGroup.add(ring);
                }
                nodeGroup.add(ringsGroup);
                nodeGroup.userData.ringsGroup = ringsGroup;

                const labelDiv = document.createElement('div');
                labelDiv.className = 'node-label';
                labelDiv.textContent = nodeData.displayText || nodeData.id;
                labelDiv.setAttribute('data-id', nodeData.id);
                const label = new THREE.CSS2DObject(labelDiv);
                label.position.set(0, size*1.4, 0);
                nodeGroup.add(label);

                nodeGroup.userData.nodeData = nodeData;
                nodeGroup.userData.label = label;
                nodes.set(nodeData.id, nodeGroup);
                graphGroup.add(nodeGroup);
            });
        });
    }

    function createEdges(){
        graphDataFull.edges.forEach(edgeData=>{
            const sourceNode = nodes.get(edgeData.source);
            const targetNode = nodes.get(edgeData.target);
            if(!sourceNode || !targetNode) return;
            const startVec = sourceNode.position;
            const endVec = targetNode.position;
            const midPoint = new THREE.Vector3().addVectors(startVec, endVec).multiplyScalar(0.5);
            const distance = startVec.distanceTo(endVec);
            const controlPoint = midPoint.clone().normalize().multiplyScalar(midPoint.length() + distance * 0.75);
            const mainCurve = new THREE.QuadraticBezierCurve3(startVec, controlPoint, endVec);

            const color = relationToColor(edgeData.relation);
            const originalColor = new THREE.Color(color);
            const dnaGroup = createDnaStrands(mainCurve, originalColor, edgeData.source === 'Akbar');
            graphGroup.add(dnaGroup);

            const labelDiv = document.createElement('div');
            labelDiv.className = 'edge-relation-label';
            labelDiv.textContent = edgeData.relation;
            labelDiv.setAttribute('data-source', edgeData.source);
            labelDiv.setAttribute('data-target', edgeData.target);
            labelDiv.setAttribute('data-relation', edgeData.relation);
            const label = new THREE.CSS2DObject(labelDiv);
            label.position.copy(mainCurve.getPoint(0.5));
            graphGroup.add(label);

            edges.push({ ...edgeData, mesh: dnaGroup, label, originalColor });
        });
    }

    function createDnaStrands(mainCurve, color, flowsFromAkbar) {
        const numTurns = Math.max(2, mainCurve.getLength() / 4);
        const pointsPerStrand = 48;
        const frames = getSimpleFrenetFrames(mainCurve, pointsPerStrand);
        const { points, normals, binormals } = frames;
        const strandPoints1 = [], strandPoints2 = [];
        for (let i=0;i<=pointsPerStrand;i++){
            const t = i/pointsPerStrand;
            const pointOnCurve = points[i];
            const angle = t * numTurns * Math.PI * 2;
            const offset = normals[i].clone().multiplyScalar(Math.cos(angle) * 0.22).add(binormals[i].clone().multiplyScalar(Math.sin(angle) * 0.22));
            strandPoints1.push(pointOnCurve.clone().add(offset));
            strandPoints2.push(pointOnCurve.clone().add(offset.clone().negate()));
        }
        const material = new THREE.ShaderMaterial({
            uniforms: {
                uColor: { value: color },
                uTime: { value: 0 },
                uFlowSpeed: { value: flowsFromAkbar ? 4.0 : -4.0 },
                uIsHighlighted: { value: 0.0 }
            },
            vertexShader: flowVertexShader,
            fragmentShader: flowFragmentShader,
            transparent: true,
            depthWrite: false
        });
        const tubeGeo1 = new THREE.TubeGeometry(new THREE.CatmullRomCurve3(strandPoints1), pointsPerStrand, 0.04, 8, false);
        const tubeGeo2 = new THREE.TubeGeometry(new THREE.CatmullRomCurve3(strandPoints2), pointsPerStrand, 0.04, 8, false);
        const dnaGroup = new THREE.Group();
        dnaGroup.add(new THREE.Mesh(tubeGeo1, material));
        dnaGroup.add(new THREE.Mesh(tubeGeo2, material.clone()));
        return dnaGroup;
    }

    function getSimpleFrenetFrames(curve, segments) {
        const points = [], tangents = [], normals = [], binormals = [];
        let lastNormal = new THREE.Vector3(0,1,0);
        for (let i=0;i<=segments;i++){
            const t = i/segments;
            points.push(curve.getPointAt(t));
            const tangent = curve.getTangentAt(t).normalize();
            tangents.push(tangent);
            let normal;
            if (Math.abs(tangent.y) > 0.999) {
                normal = new THREE.Vector3().crossVectors(tangent, new THREE.Vector3(1,0,0)).normalize();
            } else {
                normal = new THREE.Vector3().crossVectors(tangent, new THREE.Vector3(0,1,0)).normalize();
            }
            if (i>0 && normal.dot(lastNormal) < 0) normal.negate();
            normals.push(normal);
            lastNormal = normal;
            const binormal = new THREE.Vector3().crossVectors(tangent, normal).normalize();
            binormals.push(binormal);
        }
        return { points, tangents, normals, binormals };
    }

    // --- Interaction & highlighting (kept logic) ---
    function onDocumentClick(event) {
        // Block clicks inside the left UI from hitting the canvas
        if (event.target.closest('#info')) return;

        // label click handlers
        if (event.target.classList.contains('node-label')) {
            const nodeId = event.target.getAttribute('data-id');
            const nodeData = graphDataFull.nodes.find(n => n.id === nodeId);
            if (nodeData) applyHighlight(nodeData);
            return;
        }
        if (event.target.classList.contains('edge-relation-label')) {
            const source = event.target.getAttribute('data-source');
            const target = event.target.getAttribute('data-target');
            const rel = event.target.getAttribute('data-relation');
            const e = graphDataFull.edges.find(en => en.source===source && en.target===target && en.relation===rel);
            if (e) applyEdgeHighlight(e);
            return;
        }

        // do 3D raycast elsewhere
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(graphGroup.children, true);

        let clickedNodeData = null;
        if (intersects.length > 0) {
            for (const inter of intersects) {
                if (inter.object.userData && inter.object.userData.isNodeSphere) {
                    clickedNodeData = inter.object.userData.nodeData;
                    break;
                }
            }
        }
        if (clickedNodeData) applyHighlight(clickedNodeData);
        else clearHighlights();
    }

    function clearHighlights() {
        if (!highlightedElements) return;
        nodes.forEach((nodeGroup) => {
            const sph = nodeGroup.getObjectByProperty('isNodeSphere', true);
            if (sph) {
                sph.material.opacity = NORMAL_NODE_OPACITY;
                sph.material.emissive.setHex(0x000000);
            }
            if (nodeGroup.userData.label) nodeGroup.userData.label.element.style.opacity = 1;
        });
        edges.forEach(edge => {
            edge.mesh.children.forEach(child=>{
                if (child.material && child.material.uniforms) child.material.uniforms.uIsHighlighted.value = 0.0;
            });
            if (edge.label) edge.label.element.style.opacity = 1;
        });
        highlightedElements = null;
        document.getElementById('node-inspector-display').style.display = 'none';
    }

    function applyHighlight(nodeData) {
        if (!nodeData) return;
        clearHighlights();
        const connectedEdges = edges.filter(e => e.source === nodeData.id || e.target === nodeData.id);
        const connectedNodes = new Set([nodeData]);
        connectedEdges.forEach(edge=>{
            const s = graphDataFull.nodes.find(n=>n.id===edge.source);
            const t = graphDataFull.nodes.find(n=>n.id===edge.target);
            if (s) connectedNodes.add(s);
            if (t) connectedNodes.add(t);
        });
        highlightedElements = { clickedNode: nodeData, nodes: connectedNodes, edges: new Set(connectedEdges) };

        nodes.forEach((nodeGroup) => {
            const isHighlighted = Array.from(connectedNodes).some(n => n.id === nodeGroup.userData.nodeData.id);
            const sph = nodeGroup.getObjectByProperty('isNodeSphere', true);
            if (sph) sph.material.opacity = isHighlighted ? 1.0 : FAINT_OPACITY;
            if (nodeGroup.userData.label) nodeGroup.userData.label.element.style.opacity = isHighlighted ? 1 : FAINT_OPACITY;
        });

        edges.forEach(edge=>{
            const isHighlighted = highlightedElements.edges.has(edge);
            edge.mesh.children.forEach(child=>{
                if (child.material && child.material.uniforms) child.material.uniforms.uIsHighlighted.value = isHighlighted ? 1.0 : 0.0;
            });
            if (edge.label) edge.label.element.style.opacity = isHighlighted ? 1 : FAINT_OPACITY;
        });

        displayNodeInfo(nodeData, connectedEdges);
        flyToNode(nodeData.id);
    }

    function applyEdgeHighlight(edgeData){
        if (!edgeData) return;
        clearHighlights();
        const s = graphDataFull.nodes.find(n=>n.id===edgeData.source);
        const t = graphDataFull.nodes.find(n=>n.id===edgeData.target);
        const thisEdge = edges.find(e=>e.source===edgeData.source && e.target===edgeData.target && e.relation===edgeData.relation);
        if (!s || !t || !thisEdge) return;
        highlightedElements = { clickedNode: null, nodes: new Set([s,t]), edges: new Set([thisEdge]) };
        nodes.forEach(nodeGroup=>{
            const id = nodeGroup.userData.nodeData.id;
            const isHighlighted = id===s.id || id===t.id;
            const sph = nodeGroup.getObjectByProperty('isNodeSphere', true);
            if (sph) sph.material.opacity = isHighlighted ? 1.0 : FAINT_OPACITY;
            if (nodeGroup.userData.label) nodeGroup.userData.label.element.style.opacity = isHighlighted ? 1 : FAINT_OPACITY;
        });
        edges.forEach(edge=>{
            const isHighlighted = edge===thisEdge;
            edge.mesh.children.forEach(child=>{
                if (child.material && child.material.uniforms) child.material.uniforms.uIsHighlighted.value = isHighlighted ? 1.0 : 0.0;
            });
            if (edge.label) edge.label.element.style.opacity = isHighlighted ? 1 : FAINT_OPACITY;
        });
        displayNodeInfo(s, [thisEdge]);
        flyToNode(s.id);
    }

    function displayNodeInfo(nodeData, connectedEdges){
        document.getElementById('node-inspector-display').style.display = 'block';
        document.getElementById('node-id-text').textContent = nodeData.displayText || nodeData.id;
        document.getElementById('node-type-text').textContent = nodeData.type || '';
        document.getElementById('node-category-text').textContent = getNodeCategory(nodeData);
        const list = document.getElementById('node-connections-list');
        list.innerHTML = '';
        connectedEdges.forEach(edge=>{
            const otherId = edge.source === nodeData.id ? edge.target : edge.source;
            const other = graphDataFull.nodes.find(n=>n.id===otherId);
            const li = document.createElement('li');
            li.innerHTML = `${edge.relation} <strong>${other ? other.displayText || otherId : otherId}</strong>`;
            list.appendChild(li);
        });
        document.getElementById('node-connections-details').style.display = connectedEdges.length > 0 ? 'block' : 'none';
    }

    // simple camera fly-to (lerp based)
    let cameraTween = null;
    function flyToNode(nodeId) {
        const g = nodes.get(nodeId);
        if (!g) return;
        const targetPos = g.position.clone();
        const newCam = targetPos.clone().add(new THREE.Vector3(0,8,20));
        cameraTween = {
            fromPos: camera.position.clone(),
            toPos: newCam,
            fromTarget: controls.target.clone(),
            toTarget: targetPos,
            start: performance.now(),
            dur: 700
        };
    }
    function updateCameraTween(){
        if (!cameraTween) return;
        const now = performance.now();
        const t = Math.min(1, (now - cameraTween.start) / cameraTween.dur);
        const ease = t<0.5 ? 2*t*t : -1 + (4-2*t)*t;
        camera.position.lerpVectors(cameraTween.fromPos, cameraTween.toPos, ease);
        controls.target.lerpVectors(cameraTween.fromTarget, cameraTween.toTarget, ease);
        controls.update();
        if (t >= 1) cameraTween = null;
    }

    // search index
    function buildSearchIndex(){
        searchIndex = [];
        graphDataFull.nodes.forEach(n=>{
            searchIndex.push({ id: n.id, name: (n.displayText || n.id).toLowerCase(), displayText: n.displayText || n.id, ...n });
        });
    }

    // search UI handlers
    const searchBox = document.getElementById('search-box');
    const searchSuggestions = document.getElementById('search-suggestions');
    searchBox.addEventListener('input', (e)=>{
        const term = e.target.value.trim().toLowerCase();
        searchSuggestions.innerHTML = '';
        if (term.length < 2) { searchSuggestions.style.display = 'none'; return; }
        const results = searchIndex.filter(n => n.name.includes(term)).slice(0, 8);
        if (results.length === 0) {
            const d = document.createElement('div'); d.className = 'suggestion-item'; d.textContent = 'No matches'; searchSuggestions.appendChild(d); searchSuggestions.style.display = 'block'; return;
        }
        results.forEach(r=>{
            const d = document.createElement('div'); d.className='suggestion-item'; d.textContent = r.displayText; d.dataset.id = r.id;
            d.addEventListener('click', ()=>{
                const node = graphDataFull.nodes.find(x=>x.id === r.id);
                if (node) applyHighlight(node);
                searchSuggestions.style.display = 'none';
                searchBox.value = r.displayText;
            });
            searchSuggestions.appendChild(d);
        });
        searchSuggestions.style.display = 'block';
    });
    searchBox.addEventListener('keydown', (e)=>{
        if (e.key === 'Escape') { searchSuggestions.style.display = 'none'; }
        if (e.key === 'Enter') {
            const first = searchSuggestions.querySelector('.suggestion-item[data-id]');
            if (first) {
                const n = graphDataFull.nodes.find(x=>x.id===first.dataset.id);
                if (n) applyHighlight(n);
                searchSuggestions.style.display = 'none';
            }
        }
    });

    // animate loop
    function animate(){
        requestAnimationFrame(animate);
        const dt = clock.getDelta();
        const t = clock.getElapsedTime();
        if (autoRotation) graphGroup.rotation.y += autoRotationSpeed * dt * 60;
        nodes.forEach(g=>{
            if (g.userData.ringsGroup) {
                g.userData.ringsGroup.rotation.y += dt * 0.2;
            }
        });
        edges.forEach(edge=>{
            edge.mesh.children.forEach(strand=>{
                if (strand.material && strand.material.uniforms) strand.material.uniforms.uTime.value = t;
            });
        });
        updateHighlightPulse(t);
        updateCameraTween();
        controls.update();
        renderer.render(scene, camera);
        labelRenderer.render(scene, camera);
    }

    function updateHighlightPulse(time) {
        if (!highlightedElements) return;
        const pulse = (Math.sin(time * 4) + 1) / 2;
        highlightedElements.nodes.forEach(nd=>{
            const g = nodes.get(nd.id);
            if (!g) return;
            const sph = g.getObjectByProperty('isNodeSphere', true);
            if (!sph) return;
            const isClicked = highlightedElements.clickedNode && highlightedElements.clickedNode.id === nd.id;
            const col = isClicked ? new THREE.Color(0xffff00) : nd.originalColor || new THREE.Color(0xaaaaaa);
            sph.material.emissive.copy(col).multiplyScalar(pulse * 0.7);
        });
    }

    // --- UI controls hooking: module focus buttons & file upload & wallet UI --- //
    document.querySelectorAll('.btn[data-node]').forEach(b=>{
        b.addEventListener('click', ()=> {
            const id = b.getAttribute('data-node');
            const node = graphDataFull.nodes.find(n=>n.id === id);
            if (node) applyHighlight(node);
        });
    });

    // file uploads for AI command center (client-side only; files are kept in memory)
    const uploadedList = document.getElementById('uploaded-list');
    document.getElementById('ai-files').addEventListener('change', (ev)=>{
        const files = Array.from(ev.target.files);
        uploadedList.innerHTML = '';
        files.forEach(f=>{
            const li = document.createElement('div'); li.textContent = f.name + ' (' + Math.round(f.size/1024) + ' KB)';
            uploadedList.appendChild(li);
            // read content into memory if small — for demo only
            const reader = new FileReader();
            reader.onload = () => {
                // store on the node (runtime only)
                const node = graphDataFull.nodes.find(n=>n.id==='AI_FileReader');
                if (!node._files) node._files = [];
                node._files.push({ name: f.name, content: reader.result });
            };
            reader.readAsText(f.slice(0, 1024*200)); // read first 200KB for demo
        });
    });

    // wallet monitor (client-only)
    let monitoredWallet = null;
    const walletStatus = document.getElementById('wallet-status');
    document.getElementById('btn-monitor').addEventListener('click', ()=>{
        const v = document.getElementById('wallet-input').value.trim();
        if (!v) { walletStatus.textContent = 'Please paste a wallet address or exchange id.'; return; }
        monitoredWallet = v;
        walletStatus.textContent = 'Monitoring (client-only): ' + monitoredWallet + ' — no external calls yet.';
        // For privacy & security we do not call any APIs automatically. If you want,
        // call external explorer APIs here (requires API keys) or set up a secure backend.
    });

    // simulated trade execution (client-only)
    document.getElementById('btn-sim-trade').addEventListener('click', ()=>{
        const node = graphDataFull.nodes.find(n=>n.id==='Autonomous_Layer');
        // create a simulated order result
        const sim = {
            id: 'sim-' + Date.now(),
            time: new Date().toISOString(),
            wallet: monitoredWallet || 'NO_WALLET_SET',
            action: 'BUY',
            symbol: 'BTC/USDT',
            qty: 0.001,
            price: 50000,
            status: 'EXECUTED_SIMULATION'
        };
        // show result in UI via an alert (you can replace by a nicer modal)
        alert('Simulated trade executed:\n' + JSON.stringify(sim, null, 2) + '\n\nReminder: this is only a simulation. To execute real trades, integrate a secure backend and never put API secrets in the browser.');
    });

    // --- Initialization ---
    try {
        init();
    } catch (err) {
        console.error('Init error', err);
        const ed = document.createElement('div'); ed.style.cssText = 'position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);background:#111;padding:10px;border:1px solid red;color:#fff'; ed.textContent = 'Initialization error: ' + err.message; document.body.appendChild(ed);
    }

    // Expose safe hooks for advanced users in console
    window.graphDataFull = graphDataFull;
    window.nodesMap = nodes;
    window.applyHighlight = applyHighlight;

    // NOTE AND SECURITY: If you want real trading, monitoring, or on-chain actions:
    // 1) Do NOT place API secrets in this single-file client. It is insecure.
    // 2) Instead, create a minimal backend (Node/Express) that stores secrets encrypted and performs signed requests.
    // 3) This client can call that backend (CORS + auth) to trigger trades / read balances.
    // If you'd like, I can produce that secure backend code next (recommended).
    </script>
</body>
</html>

