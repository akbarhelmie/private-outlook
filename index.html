<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Advanced Intelligence Dashboard — Single File (Client-only)</title>

<!-- Tailwind CDN for quick UI -->
<script src="https://cdn.tailwindcss.com"></script>
<link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;700&display=swap" rel="stylesheet">
<style>
  :root{--bg:#0b1220;--panel:rgba(15,20,28,0.88);--muted:#9fb0c8}
  body{margin:0;background:var(--bg);font-family:'Nunito',sans-serif;color:#e7f0ff;overflow:hidden}
  #left { position: absolute; left:12px; top:12px; width:410px; max-height:94vh; overflow:auto; background:var(--panel); padding:14px; border-radius:10px; border:1px solid rgba(255,255,255,0.04); z-index:150 }
  h1{margin:0 0 8px 0;font-weight:700}
  .module{background:rgba(255,255,255,0.02);padding:10px;border-radius:8px;margin-bottom:8px;border:1px solid rgba(255,255,255,0.02)}
  .small{font-size:13px;color:var(--muted)}
  #map-hint{position:absolute;right:12px;bottom:12px;background:rgba(255,255,255,0.02);padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);font-size:12px;z-index:150}
  canvas{display:block}
  .label-node{cursor:pointer}
  #news-list{max-height:180px;overflow:auto}
  .news-item{padding:6px;border-bottom:1px solid rgba(255,255,255,0.02)}
  .rule-row{display:flex;gap:6px;align-items:center;margin-bottom:6px}
  .pill{background:rgba(255,255,255,0.03);padding:4px 8px;border-radius:6px;border:1px solid rgba(255,255,255,0.02)}
  .warning{color:#ffb4b4;font-size:12px}
  code{background:rgba(255,255,255,0.02);padding:2px 6px;border-radius:4px;font-size:12px}
</style>
</head>
<body>
  <div id="left">
    <h1>Intelligence Dashboard — Client Mode</h1>
    <div class="small">Realtime market + top-10 news + local IF-THEN rule engine. No secrets in browser. Paste wallet/portfolio if you want portfolio-specific suggestions.</div>

    <div class="module mt-3">
      <div class="flex justify-between items-center">
        <div><strong>Market Watch</strong><div class="small">BTC + selected tokens (live via CoinGecko)</div></div>
        <button id="btn-refresh-prices" class="pill">Refresh</button>
      </div>
      <div id="market-list" class="mt-2 small"></div>
      <div class="small mt-2">Filter: <input id="market-filter" placeholder="min market cap (USD)" class="pill" style="width:140px" value="100000"/></div>
    </div>

    <div class="module">
      <strong>Top-10 News (finance + crypto)</strong>
      <div class="small">Aggregated from major outlets (ref. Bloomberg, Reuters, FT, Investing.com, CoinDesk, CoinTelegraph, The Block, Decrypt, CNBC, WSJ).</div>
      <div id="news-controls" class="mt-2">
        <button id="btn-refresh-news" class="pill">Refresh News</button>
        <button id="btn-scan-keywords" class="pill">Scan Keywords</button>
      </div>
      <div id="news-list" class="mt-2"></div>
    </div>

    <div class="module">
      <strong>Wallet / Portfolio (Paste your holdings)</strong>
      <div class="small">For safety: paste read-only holdings (symbol + qty). Example format (CSV or JSON): BTC,0.02</div>
      <textarea id="portfolio-input" rows="4" class="w-full mt-2" placeholder="BTC,0.02\nETH,0.5\nDOGE,1000"></textarea>
      <div class="mt-2 flex gap-2">
        <button id="btn-import-portfolio" class="pill">Import</button>
        <button id="btn-clear-portfolio" class="pill">Clear</button>
      </div>
      <div id="portfolio-summary" class="mt-2 small"></div>
    </div>

    <div class="module">
      <strong>Autonomous Layer — Rules (local)</strong>
      <div class="small mb-2">Create local IF-THIS-THEN-THAT rules. Rules are evaluated in the browser using price & news data. On match, you'll get recommendations (NO automatic orders).</div>

      <div id="rules-list" class="mb-2 small"></div>

      <div class="mt-2">
        <div class="small font-semibold">Create Rule</div>
        <div class="rule-row">
          <select id="rule-type" class="pill"><option value="price-drop">Price Drop</option><option value="price-rise">Price Rise</option><option value="news-match">News Keyword</option></select>
          <input id="rule-symbol" placeholder="Symbol (e.g. btc)" class="pill" />
        </div>
        <div class="rule-row">
          <input id="rule-threshold" placeholder="threshold (e.g. 7 for 7%)" class="pill" />
          <input id="rule-hours" placeholder="hours (e.g. 6)" class="pill" />
        </div>
        <div class="rule-row">
          <input id="rule-keywords" placeholder="keywords (comma) - for news rules" class="pill" />
          <button id="btn-add-rule" class="pill">Add Rule</button>
        </div>
      </div>

    </div>

    <div class="module">
      <strong>Triggered Actions & Suggestions</strong>
      <div class="small mt-1">When a rule triggers, the system will propose actions and a short multi-step plan that touches vision 1–6.</div>
      <div id="triggers" class="mt-2 small"></div>
    </div>

    <div class="small mt-3 warning">
      ⚠️ Security notes: This page does not and should not store private keys. If you later decide to execute trades programmatically, we must add a secure backend that holds your API keys safely and signs requests server-side.
    </div>
    <div class="small mt-2">
      Implementation notes & sources: CoinGecko for live market data (public), and top news sources chosen from aggregated lists of major financial & crypto publishers. See assistant for details/references.
    </div>
  </div>

  <div id="map-hint" class="small">Click node labels in the 3D view to inspect • Rules run locally</div>

  <!-- Three.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/renderers/CSS2DRenderer.js"></script>

  <script>
  /************************************************************************
   * Single-file Intelligence Dashboard (client-only)
   * - Market data via CoinGecko (public).
   * - News via RSS fetch using allorigins.win proxy (to avoid CORS).
   * - Local wallet import (user pastes holdings).
   * - Local rule engine: price-change & news-keyword rules.
   * - On trigger: propose multi-vision actions and simulated trade suggestion.
   *
   * IMPORTANT:
   * - This is intentionally client-side only. No API keys or private keys are accepted.
   * - If you later want to execute real trades, you'll need a backend that holds keys.
   *************************************************************************/

  // === Config / sources ===
  const COINGECKO_BASE = 'https://api.coingecko.com/api/v3';
  // Top-10 news sources (finance + crypto). We'll attempt to fetch RSS feeds for each.
  // If a feed isn't available, we'll fallback to the site front page via the CORS proxy.
  const NEWS_SOURCES = [
    { id:'bloomberg', name:'Bloomberg', rss:'https://www.bloomberg.com/feed/podcast/etf-report.xml' }, // bloomberg has many feeds; sample used
    { id:'reuters', name:'Reuters', rss:'https://www.reutersagency.com/feed/?best-topics=business-finance' }, // fallback
    { id:'ft', name:'Financial Times', rss:'https://www.ft.com/?format=rss' },
    { id:'wsj', name:'Wall Street Journal', rss:'https://feeds.a.dj.com/rss/RSSMarketsMain.xml' },
    { id:'investing', name:'Investing.com', rss:'https://www.investing.com/rss/news.rss' },
    { id:'cnbc', name:'CNBC', rss:'https://www.cnbc.com/id/100003114/device/rss/rss.html' },
    { id:'coindesk', name:'CoinDesk', rss:'https://www.coindesk.com/arc/outboundfeeds/rss/' },
    { id:'cointelegraph', name:'Cointelegraph', rss:'https://cointelegraph.com/rss' },
    { id:'theblock', name:'The Block', rss:'https://www.theblock.co/rss.xml' },
    { id:'decrypt', name:'Decrypt', rss:'https://decrypt.co/feed' }
  ];
  // CORS proxy: allorigins (public free) - for production host your own proxy
  const CORS_PROXY_RAW = 'https://api.allorigins.win/raw?url=';

  // simple in-memory state
  let marketState = {}; // key: symbol (lowercase), value: {price, market_cap, change_24h, timestamps...}
  let portfolio = {}; // symbol -> qty
  let rules = []; // list of rule objects
  let triggers = []; // triggered events

  // Helper: pretty numbers
  function fmt(n){ if(n === null || n === undefined) return '-'; if(n >= 1e9) return (n/1e9).toFixed(2)+'B'; if(n >= 1e6) return (n/1e6).toFixed(2)+'M'; if(n >= 1e3) return (n/1e3).toFixed(2)+'k'; return Number(n).toFixed(4).replace(/\.?0+$/,''); }

  // === Market data fetching (CoinGecko) ===
  // We'll poll coin list and markets; support low-cap tokens by filtering market_cap >= threshold
  async function fetchMarkets(minMarketCap=100000){
    try{
      // fetch top 250 markets (per page) — we can page if needed
      const url = `${COINGECKO_BASE}/coins/markets?vs_currency=usd&order=market_cap_desc&per_page=250&page=1&price_change_percentage=1h%2C24h%2C7d`;
      const r = await fetch(url);
      const data = await r.json();
      // filter by market cap threshold
      const filtered = data.filter(c => c.market_cap && c.market_cap >= minMarketCap);
      const newState = {};
      filtered.forEach(c=>{
        newState[c.symbol.toLowerCase()] = {
          id: c.id,
          symbol: c.symbol.toLowerCase(),
          name: c.name,
          price: c.current_price,
          market_cap: c.market_cap,
          change_24h: c.price_change_percentage_24h,
          last_updated: c.last_updated
        };
      });
      marketState = {...marketState, ...newState};
      renderMarketList();
      return newState;
    }catch(err){
      console.error('fetchMarkets err',err);
    }
  }

  function renderMarketList(){
    const cont = document.getElementById('market-list');
    cont.innerHTML = '';
    const arr = Object.values(marketState).sort((a,b)=>b.market_cap - a.market_cap).slice(0,80);
    arr.forEach(m=>{
      const div = document.createElement('div');
      div.className = 'flex justify-between items-center py-1';
      div.innerHTML = `<div>
          <strong style="text-transform:uppercase">${m.symbol}</strong> <span class="small"> - ${m.name}</span><br/>
          <span class="small">Price: $${fmt(m.price)} • MC: ${fmt(m.market_cap)} • 24h: ${m.change_24h ? m.change_24h.toFixed(2)+'%' : '-'}</span>
        </div>
        <div class="text-right">
          <button class="pill" data-symbol="${m.symbol}">Inspect</button>
        </div>`;
      cont.appendChild(div);
    });
    // attach inspect handlers
    cont.querySelectorAll('button[data-symbol]').forEach(b=>b.addEventListener('click', (ev)=>{
      const sym = b.getAttribute('data-symbol');
      suggestActionsForSymbol(sym);
    }));
  }

  // === News fetching (RSS via CORS proxy) ===
  // We fetch each RSS URL via allorigins raw proxy, parse XML, extract items.
  async function fetchNewsAll(){
    const container = document.getElementById('news-list');
    container.innerHTML = '<div class="small">Fetching news...</div>';
    const allArticles = [];
    for (const s of NEWS_SOURCES){
      try{
        // encode rss url
        const target = encodeURIComponent(s.rss);
        const proxied = `${CORS_PROXY_RAW}${s.rss}`;
        const res = await fetch(proxied);
        if (!res.ok) { console.warn('news fetch failed', s.name); continue; }
        const text = await res.text();
        const parser = new DOMParser();
        const xml = parser.parseFromString(text, "text/xml");
        const items = xml.querySelectorAll('item');
        let count = 0;
        items.forEach(it=>{
          if (count++ > 6) return; // limit per source
          const title = it.querySelector('title') ? it.querySelector('title').textContent : null;
          const link = it.querySelector('link') ? it.querySelector('link').textContent : null;
          const pub = it.querySelector('pubDate') ? it.querySelector('pubDate').textContent : '';
          allArticles.push({source:s.name, title, link, pub});
        });
      }catch(err){
        console.warn('fetchNewsAll error for', s.name, err);
        // try fallback: fetch site home page and extract <title>
        try{
          const proxiedSite = `${CORS_PROXY_RAW}${encodeURIComponent('https://'+s.name.toLowerCase()+'.com')}`;
          const r2 = await fetch(proxiedSite);
          const t2 = await r2.text();
          const tit = (t2.match(/<title>(.*?)<\/title>/i) || [null,''])[1];
          if(tit) allArticles.push({source:s.name, title: tit, link: 'https://'+s.name.toLowerCase()+'.com', pub: ''});
        }catch(e){/*ignore*/}
      }
    }
    // sort by pub (best-effort)
    // render top N
    const sorted = allArticles.slice(0,150);
    container.innerHTML = '';
    sorted.slice(0,30).forEach(a=>{
      const el = document.createElement('div');
      el.className = 'news-item';
      el.innerHTML = `<div style="font-weight:700">${a.title || '(no title)'}</div>
                      <div class="small">${a.source} • ${a.pub}</div>
                      <div style="margin-top:6px"><a target="_blank" rel="noreferrer" href="${a.link}">Open</a></div>`;
      container.appendChild(el);
    });
    return sorted;
  }

  // Simple keyword scan on latest fetched news; returns matched headlines
  async function scanNewsKeywords(keywordsRaw){
    const keywords = keywordsRaw.split(',').map(k=>k.trim().toLowerCase()).filter(Boolean);
    if (keywords.length === 0) return [];
    const articles = await fetchNewsAll();
    const matches = articles.filter(a=>{
      const t = (a.title || '').toLowerCase();
      return keywords.some(k => t.includes(k));
    });
    return matches;
  }

  // === Portfolio import ===
  function parsePortfolioText(txt){
    // supports CSV lines symbol,qty
    const lines = txt.split('\n').map(l=>l.trim()).filter(Boolean);
    const out = {};
    lines.forEach(l=>{
      const parts = l.split(/[,\s]+/).map(p=>p.trim()).filter(Boolean);
      if (parts.length >= 2){
        const sym = parts[0].toLowerCase();
        const qty = parseFloat(parts[1]);
        if (!isNaN(qty)) out[sym] = (out[sym] || 0) + qty;
      }
    });
    portfolio = out;
    renderPortfolioSummary();
  }
  function renderPortfolioSummary(){
    const el = document.getElementById('portfolio-summary');
    const keys = Object.keys(portfolio);
    if (keys.length === 0){ el.innerHTML = '<div class="small">No holdings imported.</div>'; return; }
    let html = '<div class="small">Imported holdings:</div><ul>';
    keys.forEach(k=>{
      const price = marketState[k] ? marketState[k].price : null;
      const val = price ? price * portfolio[k] : null;
      html += `<li>${k.toUpperCase()}: ${portfolio[k]} — ${val ? '$' + fmt(val) : '<em>price not loaded</em>'}</li>`;
    });
    html += '</ul>';
    el.innerHTML = html;
  }

  // === Rule engine ===
  // Rule schema: {id, type: 'price-drop'|'price-rise'|'news-match', symbol, threshold (percent), hours, keywords, active}
  function addRule(rule){
    rule.id = 'r'+Date.now();
    rule.active = true;
    rules.push(rule);
    renderRules();
  }
  function removeRule(id){
    rules = rules.filter(r=>r.id!==id);
    renderRules();
  }
  function renderRules(){
    const container = document.getElementById('rules-list');
    container.innerHTML = '';
    if (rules.length === 0) { container.innerHTML = '<div class="small">No rules configured.</div>'; return; }
    rules.forEach(r=>{
      const div = document.createElement('div');
      div.className = 'flex items-center justify-between';
      div.innerHTML = `<div class="small">${r.type} • ${r.symbol || ''} • ${r.threshold ? r.threshold+'%' : ''} • ${r.hours || ''}h ${r.keywords ? '• "'+r.keywords+'"' : ''}</div>
                       <div><button class="pill btn-run" data-id="${r.id}">Run</button> <button class="pill btn-del" data-id="${r.id}">Delete</button></div>`;
      container.appendChild(div);
    });
    container.querySelectorAll('.btn-run').forEach(b=>b.addEventListener('click', async (e)=>{
      const id = b.dataset.id; const ru = rules.find(x=>x.id===id); if(ru) await evaluateRule(ru,true);
    }));
    container.querySelectorAll('.btn-del').forEach(b=>b.addEventListener('click', (e)=>{ removeRule(b.dataset.id); }));
  }

  // Evaluate a single rule; if testRun=true show immediate result; otherwise add to triggers if matched.
  async function evaluateRule(rule, testRun=false){
    if (rule.type === 'news-match'){
      const matches = await scanNewsKeywords(rule.keywords || '');
      if (matches.length > 0){
        const outcome = {rule, matches, time: new Date().toISOString()};
        if (!testRun) pushTrigger(outcome);
        else alert('Rule matches '+matches.length+' articles. See console for details.'), console.log(matches);
        proposeActionsForTrigger(outcome);
        return true;
      } else {
        if (testRun) alert('No news matches found.');
        return false;
      }
    } else if (rule.type === 'price-drop' || rule.type === 'price-rise'){
      const sym = (rule.symbol || '').toLowerCase();
      if (!sym) { if (testRun) alert('No symbol set'); return false; }
      // ensure marketState has this coin (CoinGecko id)
      let coin = marketState[sym];
      if (!coin){
        // try to fetch markets again (maybe coin not in current list)
        await fetchMarkets(parseInt(document.getElementById('market-filter').value || '100000'));
        coin = marketState[sym];
      }
      if (!coin) { if (testRun) alert('Symbol not found in market data'); return false; }
      // fetch historical market_chart for the coin via CoinGecko to compute percent change over N hours
      try{
        const hours = Math.max(1, parseInt(rule.hours) || 6);
        const days = Math.ceil(hours / 24);
        const gid = coin.id;
        const url = `${COINGECKO_BASE}/coins/${encodeURIComponent(gid)}/market_chart?vs_currency=usd&days=${days}&interval=hourly`;
        const r = await fetch(url); const data = await r.json();
        if (!data.prices || data.prices.length === 0){ if (testRun) alert('No historical data'); return false; }
        // find timestamp for now and for N hours ago
        const now = Date.now();
        const cutoff = now - (hours * 3600 * 1000);
        // find earliest price >= cutoff
        const prices = data.prices; // [ [ts, price], ...]
        let pastPrice = prices[0][1];
        for (let i=0;i<prices.length;i++){
          if (prices[i][0] >= cutoff){ pastPrice = prices[i][1]; break; }
        }
        const currentPrice = coin.price;
        const pct = ((currentPrice - pastPrice) / pastPrice) * 100;
        let matched = false;
        if (rule.type === 'price-drop' && pct <= -Math.abs(rule.threshold || 0)) matched = true;
        if (rule.type === 'price-rise' && pct >= Math.abs(rule.threshold || 0)) matched = true;
        if (matched){
          const outcome = {rule, pastPrice, currentPrice, pct, time:new Date().toISOString()};
          if (!testRun) pushTrigger(outcome);
          else alert(`Rule matched: ${sym.toUpperCase()} moved ${pct.toFixed(2)}% (${pastPrice} -> ${currentPrice})`);
          proposeActionsForTrigger(outcome);
          return true;
        } else {
          if (testRun) alert(`Rule did not match. Change ${pct.toFixed(2)}%`);
          return false;
        }
      }catch(err){
        console.error('evaluateRule err',err);
        if (testRun) alert('Error evaluating rule; see console');
        return false;
      }
    }
    return false;
  }

  // Push a trigger to the UI log
  function pushTrigger(outcome){
    triggers.unshift(outcome);
    if (triggers.length > 50) triggers.pop();
    renderTriggers();
  }
  function renderTriggers(){
    const el = document.getElementById('triggers');
    el.innerHTML = '';
    triggers.slice(0,15).forEach(t=>{
      const d = document.createElement('div');
      d.className = 'mb-2';
      if (t.rule.type === 'news-match'){
        d.innerHTML = `<div class="pill font-semibold">NEWS TRIGGER - ${t.rule.keywords}</div>
          <div class="small mt-1">${t.matches.slice(0,3).map(m=>`${m.source}: ${m.title}`).join('<br/>')}</div>
          <div class="mt-1"><button class="pill" onclick='window.scrollTo(0,0);'>Open Planner</button></div>`;
      } else {
        d.innerHTML = `<div class="pill font-semibold">PRICE TRIGGER - ${t.rule.symbol.toUpperCase()}</div>
          <div class="small mt-1">Change: ${t.pct ? t.pct.toFixed(2)+'%' : ''} • Past: ${t.pastPrice ? '$'+fmt(t.pastPrice) : ''} • Now: ${t.currentPrice ? '$'+fmt(t.currentPrice) : ''}</div>
          <div class="mt-1"><button class="pill" onclick='suggestActionsForTrigger(${JSON.stringify(t).replace(/'/g,"\\'")})'>Open Planner</button></div>`;
      }
      el.appendChild(d);
    });
  }

  // === Planner / multi-vision suggestion generator (lightweight) ===
  // When a trigger occurs we generate a short "what to do" plan that touches visions 1..6.
  // This is local templating, not an LLM. You can wire an LLM later if you want richer text.
  function proposeActionsForTrigger(trigger){
    // create a human-readable plan and show an alert and append to triggers as extra info
    if (!trigger) return;
    const now = new Date().toISOString();
    let plan = {time: now, trigger};
    if (trigger.rule.type === 'news-match'){
      plan.title = `News triggered: ${trigger.rule.keywords}`;
      plan.steps = [
        `Vision 1 (Dashboard): Show headlines & sentiment summary from sources (top 10).`,
        `Vision 4 (Radar): Cross-check whether price/orderflow anomalies occur for related tickers.`,
        `Vision 2 (AI Command Center): Draft a short 3-step recommendation (monitor / hedge / buy) and list required docs/data.`,
        `Vision 5 (Network): Suggest contacts to alert or ask (PR/legal) if reputational risk).`,
        `Vision 6 (Vision Sync): Tag this event in timeline with KPI impact estimate.`,
        `Autonomous Layer: Queue suggested action: "Notify me and prepare buy order (simulate)".`
      ];
    } else {
      // price trigger
      const sym = trigger.rule.symbol.toUpperCase();
      plan.title = `Price movement detected for ${sym} (${trigger.pct ? trigger.pct.toFixed(2)+'%': ''})`;
      plan.steps = [
        `Vision 1: Mark buy range on dashboard; show limit price suggestions (e.g. current price, 1% and 3% below).`,
        `Vision 4: Check for suspicious volume spikes (wash trading) and label risk.`,
        `Vision 2: Draft mission-mode checklist: research recent news, review token audits, check liquidity.`,
        `Vision 5: Identify 2-3 contacts (e.g., market makers / liquidity providers) to confirm order size feasibility.`,
        `Vision 6: Create short-term KPI (entry price, target, stop loss) and log under Vision Sync.`,
        `Autonomous: Prepare a simulated buy order with size suggestion based on portfolio exposure.`
      ];
      plan.suggestedOrder = {
        symbol: sym,
        side: 'buy',
        amountUSD: computeSuggestedSizeUSD(sym)
      };
    }
    // append plan visually
    showPlanModal(plan);
    console.log('Plan generated', plan);
  }

  function computeSuggestedSizeUSD(sym){
    // Very conservative sample: 1% of portfolio USD value if portfolio present else $50
    const total = computePortfolioValueUSD();
    if (total > 0) return Math.max(10, total * 0.01);
    return 50;
  }

  function computePortfolioValueUSD(){
    let total = 0;
    for (const sym in portfolio){
      const p = marketState[sym];
      if (p) total += p.price * portfolio[sym];
    }
    return total;
  }

  function showPlanModal(plan){
    // simple modal via alert for now (can upgrade)
    let txt = `PLAN: ${plan.title}\n\nSteps:\n`;
    plan.steps.forEach((s,i)=> txt += `${i+1}. ${s}\n`);
    if (plan.suggestedOrder) txt += `\nSuggested Order: ${JSON.stringify(plan.suggestedOrder)}\n`;
    alert(txt);
  }

  // Used by inspect buttons
  function suggestActionsForSymbol(sym){
    // basic suggestion: show current market info + quick computed size
    const s = marketState[sym.toLowerCase()];
    if (!s) { alert('Symbol not available in market snapshot. Refresh markets or pick another.'); return; }
    const suggestedUSD = computeSuggestedSizeUSD(sym.toLowerCase());
    alert(`Symbol ${s.symbol.toUpperCase()} (${s.name})\nPrice: $${s.price}\nMarket Cap: $${fmt(s.market_cap)}\nSuggested buy USD (conservative): $${fmt(suggestedUSD)}`);
  }

  // Suggest actions for programmatic trigger invocation (from UI)
  function suggestActionsForTrigger(trigger){
    proposeActionsForTrigger(trigger);
  }
  window.suggestActionsForTrigger = suggestActionsForTrigger;

  // === periodic tasks ===
  async function tickAll(){
    const minMC = parseInt(document.getElementById('market-filter').value || '100000');
    await fetchMarkets(minMC);
    // fetch news in background less often
    // run rules evaluation
    evaluateAllRulesSilent();
  }

  async function evaluateAllRulesSilent(){
    for (const r of rules){
      if (!r.active) continue;
      try{ await evaluateRule(r,false); }catch(e){console.warn('rule eval err',e);}
    }
  }

  // === UI glue ===
  document.getElementById('btn-refresh-prices').addEventListener('click', ()=>{ fetchMarkets(parseInt(document.getElementById('market-filter').value||'100000')); });
  document.getElementById('btn-refresh-news').addEventListener('click', ()=>{ fetchNewsAll(); });
  document.getElementById('btn-scan-keywords').addEventListener('click', async ()=>{
    const k = prompt('Enter keywords to scan (comma separated)');
    if (!k) return;
    const matches = await scanNewsKeywords(k);
    alert('Found ' + matches.length + ' matches (console for details)');
    console.log(matches);
  });

  document.getElementById('btn-import-portfolio').addEventListener('click', ()=>{
    const txt = document.getElementById('portfolio-input').value;
    parsePortfolioText(txt);
  });
  document.getElementById('btn-clear-portfolio').addEventListener('click', ()=>{ portfolio = {}; document.getElementById('portfolio-input').value=''; renderPortfolioSummary(); });

  document.getElementById('btn-add-rule').addEventListener('click', ()=>{
    const type = document.getElementById('rule-type').value;
    const symbol = document.getElementById('rule-symbol').value.trim();
    const threshold = parseFloat(document.getElementById('rule-threshold').value || '0');
    const hours = parseInt(document.getElementById('rule-hours').value || '6');
    const keywords = document.getElementById('rule-keywords').value.trim();
    if (type.includes('price') && !symbol){ alert('Please set symbol'); return; }
    const rule = { type, symbol, threshold, hours, keywords };
    addRule(rule);
  });

  // initial fetches & interval
  (async function start(){
    await fetchMarkets(100000);
    await fetchNewsAll();
    renderRules();
    setInterval(()=>{ tickAll(); }, 20_000); // markets & rule eval every 20s
    setInterval(()=>{ fetchNewsAll(); }, 60_000); // news every 60s
  })();

  // === Three.js graph minimal — create 6 module nodes + person Akbar; clicking labels focuses ===
  // This is a light reuse of your original visual layout (keeps behaviour intentionally simple)
  (function initGraph(){
    const graphData = {
      nodes: [
        {id:'Akbar', type:'Person', displayText:'Akbar'},
        {id:'RealTime_Dashboard', type:'Module', displayText:'Real-Time Intelligence Dashboard'},
        {id:'AI_Command_Center', type:'Module', displayText:'AI Command Center'},
        {id:'Manipulation_Radar', type:'Module', displayText:'Global Market Manipulation Radar'},
        {id:'Network_Monitor', type:'Module', displayText:'Human Network Monitor'},
        {id:'Vision_Sync', type:'Module', displayText:'Vision & Reality Sync'},
        {id:'Autonomous_Layer', type:'Module', displayText:'Autonomous Action Layer'}
      ],
      edges: [
        {source:'Akbar', target:'RealTime_Dashboard', relation:'uses'},
        {source:'Akbar', target:'AI_Command_Center', relation:'operates'},
        {source:'Akbar', target:'Manipulation_Radar', relation:'monitors'},
        {source:'Akbar', target:'Network_Monitor', relation:'leverages'},
        {source:'Akbar', target:'Vision_Sync', relation:'plans'},
        {source:'Akbar', target:'Autonomous_Layer', relation:'configures'}
      ]
    };

    const nodeColors = {Person:0xff6347, Module:0x4a90e2, default:0xa9a9a9};
    let scene = new THREE.Scene();
    let camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0,20,115);
    const renderer = new THREE.WebGLRenderer({antialias:true, alpha:true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);
    const labelRenderer = new THREE.CSS2DRenderer();
    labelRenderer.setSize(window.innerWidth, window.innerHeight);
    labelRenderer.domElement.style.pointerEvents='none';
    labelRenderer.domElement.style.position='absolute';
    labelRenderer.domElement.style.top='0';
    document.body.appendChild(labelRenderer.domElement);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.target.set(0,0,0);

    scene.add(new THREE.AmbientLight(0xffffff, 0.8));
    const dir = new THREE.DirectionalLight(0xffffff, 0.6); dir.position.set(10,20,10); scene.add(dir);

    const group = new THREE.Group(); scene.add(group);

    const nodesMap = new Map();
    const golden = Math.PI*(3 - Math.sqrt(5));
    const categories = {};
    graphData.nodes.forEach((n, i)=>{
      const cat = n.type;
      if (!categories[cat]) categories[cat] = [];
      categories[cat].push(n);
    });
    const radii = {Person:0, Module:28, default:60};
    Object.entries(categories).forEach(([cat, list])=>{
      const r = radii[cat] || 60;
      list.forEach((node, idx)=>{
        const grp = new THREE.Group();
        const theta = golden * idx;
        grp.position.set(Math.cos(theta)*r, (idx%2?1:-1)* (r*0.12), Math.sin(theta)*r);
        const size = node.type === 'Person' ? 2 : 1.4;
        const sphere = new THREE.Mesh(new THREE.SphereGeometry(size, 32, 16),
          new THREE.MeshStandardMaterial({color: nodeColors[node.type] || nodeColors.default, metalness:0.1, roughness:0.7}));
        sphere.userData = { nodeData: node, isNodeSphere:true };
        grp.add(sphere);
        // label
        const div = document.createElement('div'); div.className='label-node'; div.style.pointerEvents='auto'; div.style.color='#eaf4ff';
        div.textContent = node.displayText || node.id;
        div.setAttribute('data-id', node.id);
        const label = new THREE.CSS2DObject(div); label.position.set(0, size*1.6, 0); grp.add(label);
        nodesMap.set(node.id, grp);
        group.add(grp);
      });
    });

    // edges are simple lines
    graphData.edges.forEach(e=>{
      const a = nodesMap.get(e.source); const b = nodesMap.get(e.target);
      if (!a || !b) return;
      const geom = new THREE.BufferGeometry().setFromPoints([a.position, b.position]);
      const mat = new THREE.LineBasicMaterial({color:0x8888aa, transparent:true, opacity:0.5});
      const line = new THREE.Line(geom, mat); group.add(line);
    });

    // click handlers on label elements
    document.body.addEventListener('click', (ev)=>{
      if (ev.target && ev.target.matches && ev.target.matches('.label-node')){
        const id = ev.target.getAttribute('data-id');
        // bring into focus: locate node and animate camera
        const nodeGrp = nodesMap.get(id);
        if (nodeGrp){ controls.target.copy(nodeGrp.position); camera.position.copy(nodeGrp.position.clone().add(new THREE.Vector3(0,6,24))); }
      }
    });

    function animate(){
      requestAnimationFrame(animate);
      group.rotation.y += 0.0008;
      controls.update();
      renderer.render(scene, camera);
      labelRenderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', ()=>{ camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); labelRenderer.setSize(window.innerWidth, window.innerHeight);});
  })();

  </script>
</body>
</html>
